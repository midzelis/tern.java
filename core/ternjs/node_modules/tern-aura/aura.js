(function (mod) {
    if (typeof exports == 'object' && typeof module == 'object') // CommonJS
        return mod(require('tern/lib/infer'), require('tern/lib/tern'), require('tern/plugin/modules'), require('acorn'), require('acorn/dist/acorn_loose'), require('acorn/dist/walk'));
    if (typeof define == 'function' && define.amd) // AMD
        return define(['tern/lib/infer', 'tern/lib/tern', 'tern/plugin/modules', 'acorn', 'acorn/dist/acorn_loose', 'acorn/dist/walk'], mod);
    mod(tern, tern, acorn, acorn_loose, acorn.walk);
})(function (infer, tern, modules, acorn, acorn_loose, walk) {
    'use strict';

    var WG_IMPORT_DEFAULT_FALLBACK = 80;
    var WG_DEFAULT_EXPORT = 95;

    var glob = require('glob');
    var fs = require('fs');
    var cheerio = require('cheerio');
    var JSZip = require('jszip');
    var zipcache = {};
    var server = {};
    var libsi = {};
    var jsToLib = {};
    var jsToCmp = {};

    function parent(path) {
        var splits = path.split('/');
        if (splits.size == 1) return '';
        return splits[splits.length - 3];
    }

    function dirName(path) {
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash == -1) return '';
        return path.slice(0, lastSlash + 1);
    }

    function baseName(path) {
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash == -1) return path;
        else return path.slice(lastSlash + 1);
    }

    function trimExt(path) {
        var lastDot = path.lastIndexOf('.');
        if (lastDot == -1) return path;
        else return path.slice(0, lastDot);
    }

    function initScope(scope) {
        var module = new infer.Obj();
        module.propagate(scope.defProp('module'));
        var exports = new infer.Obj(true);
        module.origin = exports.origin = scope.origin;
        module.originNode = exports.originNode = scope.originNode;
        exports.propagate(scope.defProp('exports'));
        var moduleExports = scope.exports = module.defProp('exports');
        exports.propagate(moduleExports, WG_DEFAULT_EXPORT);
    }

    function getLibraryIncludes(library) {
        var file = libsi[library];
        var t = readFile(server.options.projectDir + '/' + file);
        var $ = cheerio.load(t, {
            xmlMode: true
        });
        var a = $('aura\\:library aura\\:include');
        var bn = dirName(file);
        var includes = [];
        a.each(function (i, elem) {
            includes.push(bn + $(elem).attr('name') + '.js');
        });
        return includes;
    }

    function processIfLibrary(file, modules) {
        var libs;
        if (jsToLib) {
            var lib = jsToLib[file.name];
            libs = lib ? [lib] : [];
        } else {
            libs = search(dirName(file.name) + '*.lib');
        }
        if (libs.length > 0) {
            _debug('Process libs of: ' + file.name);
            var bn = trimExt(baseName(file.name));
            var ln = trimExt(baseName(libs[0]));
            var t = readFile(server.options.projectDir + '/' + libs[0]);
            var $ = cheerio.load(t, {
                xmlMode: true
            });
            var a = $('aura\\:library aura\\:include');
            var imps;
            a.each(function (i, elem) {
                var pp = $(elem).attr('name');
                if (bn == pp) {
                    imps = $(elem).attr('imports');
                }
            });

            // use alternate module for libs
            var ns = parent(dirName(file.name));
            var l = modules.resolveModule('mod:' + ns + ':' + ln, file.name);

            var outObj;
            if (!l.getType()) {
                outObj = new infer.Obj(true);
                outObj.origin = 'Aura';
                outObj.name = baseName(libs[0]);
                l.addType(outObj);
            } else {
                outObj = l.getType();
            }
            if (imps) {
                _debug('Process impoted libs of: ' + file.name);
                // get fn decl
                var fn = file.ast.body[0];
                var state = fn.scope;

                // bind included imports to library function....
                var imports = imps.split(',');
                for (var i = 0; i < imports.length; i++) {
                    // resolve....
                    var importedModule = imports[i].trim();
                    if (importedModule == '')
                        continue;
                    var imf;
                    var lib = l;
                    if (importedModule.indexOf(':') > -1) {
                        var splits = importedModule.split(':');

                        var qn = splits[0] + ':' + splits[1];
                        if (!libsi[qn])
                            continue;

                        lib = modules.resolveModule('mod:' + qn);
                        if (!lib.getType()) {
                            var zz = new infer.Obj(true);
                            zz.origin = 'Aura';

                            zz.name = baseName(libsi[qn]);
                            lib.addType(zz);
                        }

                        importedModule = splits[2];
                        imf = dirName(libsi[qn]) + importedModule + '.js';

                    } else {
                        imf = dirName(file.name) + importedModule + '.js';
                    }
                    if (server.findFile(imf) == null) {
                        server.addFile(imf);
                    }
                    var bno = trimExt(baseName(imf));
                    var lno = trimExt(baseName(imf));

                    var pm = state.fnType.args[i];
                    if (!pm || pm.getType(false) != null)
                        continue;

                    if (lib.getType().hasProp(importedModule)) {
                        try {
                            pm.addType(lib.getType().getProp(importedModule).getType());
                        } catch (zzz) {}
                        var z = new infer.Obj();
                        z.origin = 'BLah';
                        z.name = 'XXX';
                        pm.origin = 'asdf';
                    } else {
                        var pname = importedModule;
                        // so, in effect this isn't really used, since (at least tern.ide)
                        // calls content assist frequently that by the time this called back,
                        // the file will be reindex, and the other lib file would have already
                        /// been loaded.
                        lib.getType().on('addProp', function (prop, val) {
                            if (pname == prop) {
                                pm.addType(val);
                            }
                        });
                    }
                }
            }

            _debug('Process exported libs of: ' + file.name);
            walk.simple(file.ast, {
                ReturnStatement: function (node, state) {
                    try {
                        var parent = infer.parentNode(node, file.ast);
                        var grand = infer.parentNode(parent, file.ast);
                        var great = infer.parentNode(grand, file.ast);
                        if (great && great['type'] === 'Program') {
                            if (node.argument) {
                                if (node.argument['type'] === 'Identifier') {
                                    var t = state.props[node.argument.name];
                                    if (t) {
                                        var exported = t.getObjType();
                                        outObj.defProp(bn, node.argument).addType(exported);
                                    }
                                } else if (node.argument['type'] === 'ObjectExpression') {
                                    outObj.defProp(bn, node.argument).addType(node.argument.objType);
                                } else if (node.argument['type'] === 'FunctionExpression') {
                                    outObj.defProp(bn, node.argument).addType(state.fnType.getType());
                                } else if (node.argument['type'] === 'CallExpression') {
                                    outObj.defProp(bn, node.argument).addType(state.fnType.getType());
                                }
                            }
                        }
                    } catch (ignore) {}
                }
            }, infer.searchVisitor);

        }
    }

    function processIfComponent(file, modules) {
        var cmps;
        if (jsToCmp) {
            var cmp = jsToCmp[file.name];
            cmps = cmp ? [cmp] : [];
        } else {
            cmps = search(dirName(file.name) + '*.cmp');
        }
        if (cmps.length > 0) {
            _debug('Discover libs of: ' + cmps[0]);
            var t = readFile(server.options.projectDir + '/' + cmps[0]);
            var $ = cheerio.load(t, {
                xmlMode: true
            });
            var a = $('aura\\:import');
            $(a).each(function (i, elem) {
                var library = $(elem).attr('library');
                var property = $(elem).attr('property');

                if (!libsi || !libsi[library])
                    return;

                var lib = modules.resolveModule('mod:' + library, file.name);
                if (!lib.getType()) {
                    var zz = new infer.Obj(true);
                    zz.origin = 'Aura';
                    zz.name = baseName(libsi[library]);
                    lib.addType(zz);

                    var inc = getLibraryIncludes(library);
                    for (var i = 0; i < inc.length; i++) {
                        if (server.findFile(inc[i]) == null) server.addFile(inc[i]);
                    }
                }

                var t = file.scope.getObjType();
                try {
                    walk.simple(file.ast, {
                        FunctionExpression: function (node, state) {

                            var ss = infer.scopeAt(file.ast, node);
                            var con = ss.fnType.self.getType();

                            lib.getType().propagate(con.defProp(property));

                            throw 'stop';

                        }

                    }, infer.searchVisitor);
                } catch (ignore) {}
            });
        }
    }

    function _debug(log) {
        //console.log(log);
    }

    function connectModule(file, out) {
        if (isBlacklisted(file.name)) {
            return;
        }

        var modules = infer.cx().parent.mod.modules;


        var cx = infer.cx();
        _debug('Starting...' + file.name);

        processIfLibrary(file, modules);
        processIfComponent(file, modules);

        if (/Helper.js$/.test(file.name)) {
            _debug('Process helper exports ' + file.name);
            var outObj = new infer.Obj(true);
            outObj.origin = 'Aura';
            outObj.originNode = file.ast;
            outObj.name = baseName(file.name).replace(/.js$/, '');
            out.addType(outObj);

            try {
                walk.simple(file.ast, {
                    ObjectExpression: function (node, state) {
                        var parent = infer.parentNode(node, file.ast);
                        var grand = infer.parentNode(parent, file.ast);
                        if (grand.type == 'Program') {
                            node.objType.propagate(outObj.defProp(baseName(file.name).replace(/.js$/, '')));
                            throw 'stop';
                        }
                    }
                }, infer.searchVisitor);
            } catch (ignore) {

            }
        }


        _debug('Fixing scopes...' + file.name);
        var f = false;
        walk.simple(file.ast, {
            ObjectExpression: function (node, state) {
                var parent = infer.parentNode(node, file.ast);
                var grand = infer.parentNode(parent, file.ast);
                if (grand.type == 'Program') {
                    for (var i = 0; i < node.properties.length; ++i) {
                        var prop = node.properties[i],
                            name = infer.propName(prop);
                        if (node.properties[i].value.type == 'FunctionExpression') {

                            var fn = node.properties[i].value.scope.fnType;
                            if (!fn || !fn.name) {
                                continue;
                            }

                            if (/Renderer.js$/.test(file.name)) {

                                //step 2, assign exported type to params
                                var cmp = fn.args[0];
                                var hlp = fn.args[1];
                                if (cmp) {
                                    findAndBindComponent(cmp, server, cx, infer);
                                }
                                if (hlp) {
                                    findAndBindHelper(hlp, server, modules, file);
                                }
                            } else if (/Helper.js$/.test(file.name)) {
                                //step 2, assign exported type to params
                                var cmp = fn.args[0];

                                if (cmp) {
                                    findAndBindComponent(cmp, server, cx, infer);
                                }

                            } else if (/Controller.js$/.test(file.name)) {
                                //step 2, assign exported type to params
                                var cmp = fn.args[0];
                                var evt = fn.args[1];
                                var hlp = fn.args[2];

                                if (evt) {
                                    findAndBindEvent(evt, server, cx, infer);
                                }
                                if (cmp) {
                                    findAndBindComponent(cmp, server, cx, infer);
                                }
                                if (hlp) {
                                    findAndBindHelper(hlp, server, modules, file);
                                }
                            }
                        }
                    }
                }
            }
        });
        _debug('All done ' + file.name);
            //  console.log("Done "+file.name);
    }

    function findAndBindEvent(type, server, cx, infer) {
        if (server.mod.localaura) {
            var files = search('aura/aura-impl/src/main/resources/aura/event/Event.js');
            var f = files.length > 0 ? files[0] : null;
            if (f) {
                f = server.findFile(f);
                if (!f) server.addFile(f);
                if (f && f.scope) {
                    walk.simple(f.ast, {
                        FunctionExpression: function (node) {
                            if (node.scope && node.scope.proto && node.scope.fnType.props['prototype']) {
                                var int = infer.getInstance(node.scope.fnType.props['prototype'].getObjType());
                                int.propagate(type);
                            }
                        }
                    });
                }
            }
        } else {
            // this is slightly hacky, but have no idea how to get the event Otherwise
            var evs = cx.props['Event'];
            if (!evs)
                return;
            for (var z = 0; z < evs.length; z++) {
                var y = evs[z];
                if (y.name === 'Aura.Event') {
                    var obj = y.props['Event'].types[0].props['prototype'].getObjType();
                    var int = infer.getInstance(obj);
                    int.propagate(type);
                }
            }
        }
    }

    function findAndBindComponent(type, server, cx, infer) {
        if (server.mod.localaura) {
            var files = search('aura/aura-impl/src/main/resources/aura/component/Component.js');
            var f = files.length > 0 ? files[0] : null;
            if (f) {
                f = server.findFile(f);
                if (!f) server.addFile(f);
                if (f && f.scope) {
                    var int = infer.getInstance(f.scope.getType().props['Component'].props['prototype'].getObjType());
                    int.propagate(type);
                }
            }
        } else {
            var evs = cx.props['Component'];
            if (!evs)
                return;
            for (var z = 0; z < evs.length; z++) {
                var y = evs[z];
                if (y.name === 'Aura.Component') {
                    var obj = y.props['Component'].types[0].props['prototype'].getObjType();
                    var int = infer.getInstance(obj);
                    int.propagate(type);
                }
            }
        }
    }

    function findAndBindHelper(type, server, modules, file) {

        var helperFile = getHelper(file.name);
        var bn = trimExt(baseName(helperFile));
        var r = server.findFile(helperFile);
        if (!r) server.addFile(helperFile);
        var helper = modules.resolveModule(helperFile);

        var hp = helper.getProp(bn);

        if (!hp.getType()) {
          // this handles new props added to the helper...
          helper.on('addType', function (helperType, val) {
              helperType.forAllProps(function (prop, val, local) {
                  if (bn === prop) {
                      val.propagate(type);
                  }
              });
          });
        } else {
          // now we need to handle there were changes to the .cmp,
          // but not the helper,
          helper.forAllProps(function (prop, val, local) {
              if (bn === prop) {
                  val.propagate(type);
              }
          });
        }

    }

    function getController(name) {
        return getName(name, 'Controller.js');
    }

    function getHelper(name) {
        return getName(name, 'Helper.js');
    }

    function getRenderer(name) {
        return getName(name, 'Renderer.js');
    }

    function getTest(name) {
        return getName(name, 'Test.js');
    }

    function getName(name, type) {
        var newname = name.replace(/Controller.js$|Helper.js$|Renderer.js$|Test.js$/, '') + type;
        return newname;
    }

    function resolver(file, parent) {
        return file;
    }

    function unloadDefs() {
        server.deleteDefs('Aura');
    }

    function cacheZipAsync(filename, c) {
        if (!filename.startsWith('/')) {
            filename = server.options.projectDir + '/' + filename;
        }
        if (zipcache[filename]) {
            c(null, zipcache[filename]);
            return;
        }
        _debug('Reading zip async: ' + filename);
        _debug('Look');
        _debug(c);
        fs.readFile(filename, function (err, data) {
            if (err) {
                c(err, '');
            } else {
                var z = new JSZip(data);
                _debug(z);
                zipcache[filename] = z;
                c(err, z);
            }
        });

    }

    function cacheZip(filename) {
        if (!filename.startsWith('/')) {
            filename = server.options.projectDir + '/' + filename;
        }
        if (zipcache[filename]) {
            return zipcache[filename];
        }
        _debug('Reading zip: ' + filename);
        var zip = fs.readFileSync(filename);
        var z = new JSZip(zip);
        zipcache[filename] = z;
        return z;
    }

    function isBlacklisted(filename) {
        var ret = filename.endsWith('/scrollerLib/bootstrap.js');
        ret = ret && filename.endsWith('ExportSymbolsHelper.js');
        return ret;
    }

    function readFileAsync(filename, c) {
        if (isBlacklisted(filename)) {
            c(null, '');
            return;
        }
        if (!filename.startsWith('/')) {
            filename = server.options.projectDir + '/' + filename;
        }
        if (filename.indexOf('.link') >= 0) {
            var uri = filename.split('.link/');
            var zip = uri[0];
            var nested = uri[1];
            cacheZipAsync(zip, function (err, z) {
                if (err) {
                    c(err, '');
                } else {
                    var file = z.file(nested);
                    if (file) {
                        var contents = file.asText();
                        c(null, contents);
                    } else {
                        err = new Error();
                        err.code = 'ENOENT';
                        c(err, null);
                    }
                }
            });
        } else {
            fs.readFile(filename, 'utf8', c);
        }
    }

    function readFile(filename) {
        if (isBlacklisted(filename)) {
            return '';
        }
        if (filename.indexOf('.link') >= 0) {
            var uri = filename.split('.link/');
            var zip = uri[0];
            var nested = uri[1];
            var z = cacheZip(zip);
            var contents = z.file(nested).asText();
            return contents;
        }
        return fs.readFileSync(filename, 'utf8');
    }

    function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }

    function search(spec, options) {
        if (spec.indexOf('link') >= 0) {
            //return [];
            var uri = spec.split('.link/');
            var zip = uri[0];
            var nested = uri[1];

            var searcher = nested.replace('*', 'REPLACEME');
            searcher = escapeRegExp(searcher);
            searcher = searcher.replace('REPLACEME', '.*');

            var z = cacheZip(zip);
            var matches = z.file(new RegExp(searcher));
            var fileNames = matches.map(e => zip + '.link/' + e.name);

            return fileNames;

        }
        var o = {
            cwd: server.options.projectDir
        };
        if (options) {
            Object.keys(options).forEach(function (key, index) {
                o[key] = options[key];
            });
        }
        var s = glob.sync(spec, o);
        return s;
    }

    function loadDefs() {
        var defs = readFile(dirName(__filename) + '/aura_types.json');
        defs = JSON.parse(defs);
        server.addDefs(defs);
    }

    function createIndex() {
        var cache = {};

        try {
            var c = readFile(server.options.projectDir + '/libs.json');
            libsi = JSON.parse(c);
        } catch (Err) {
            _debug(Err);
            _debug(new Date().toISOString() + ' Building .lib index...');

            glob('**/*.lib', {
                cwd: server.options.projectDir,
                ignore: '**/+(target|tmp-cache|java|build|htdocs|plsql|test)/**',
                cache: cache
            }, function (err, files) {
                _debug(new Date().toISOString() + ' done indexing .libs ' + files.length);
                for (var i = 0; i < files.length; i++) {
                    var file = files[i];

                    var ns = parent(dirName(file));
                    var n = trimExt(baseName(file));

                    libsi[ns + ':' + n] = file;
                }
                fs.writeFileSync(server.options.projectDir + '/libs.json', JSON.stringify(libsi), 'utf-8');

            });
        }
    }

    function safeFunction(fn) {
        return function () {
            try {
                fn.apply(this, arguments);
            } catch (e) {
                console.log(e);
            }
        };
    }
    tern.registerPlugin('aura', function (s, options) {
        server = s;
        server.options.getFile = readFileAsync;
        server.loadPlugin('modules');
        server.mod.modules.on('wrapScope', initScope);
        server.mod.modules.on('getExports', safeFunction(connectModule));
        server.mod.modules.resolvers.push(resolver);

        if (!options.ide) {
            _debug('Standalone mode');
            var s = search('aura/aura-impl/**/*.js');
            if (s.length > 0) {
                server.mod.localaura = true;
            } else {
                server.mod.localaura = false;
            }
            if (server.mod.localaura) {
                for (var i = 0; i < s.length; i++) {
                    var f = s[i];
                    server.addFile(s[i]);
                }
            } else {
                loadDefs();
            }

            createIndex();
        } else {
            _debug('IDE mode');
            loadDefs();
        }
        _debug(new Date().toISOString() + ' Done loading!');
    });
    tern.defineQueryType('ideInit', {
        run: function (server, query) {
            if (query.unloadDefs) {
                unloadDefs();
                _debug('Unloaded default Aura defs');
            }
            if (query.newLibIndex) {
                _debug('Loaded Lib Index');
                libsi = query.newLibIndex;
            }
            if (query.jsToLib) {
                _debug('Loaded Lib Index');
                jsToLib = query.jsToLib;
            }
            if (query.jsToCmp) {
                _debug('Loaded Cmp Index');
                jsToCmp = query.jsToCmp;
            }
            return 'OK';
        }
    });
});
