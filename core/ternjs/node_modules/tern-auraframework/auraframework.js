(function (mod) {
    if (typeof exports == "object" && typeof module == "object") // CommonJS
        return mod(require("tern/lib/infer"), require("tern/lib/tern"), require("tern/plugin/modules"), require('acorn'), require('acorn/dist/acorn_loose'), require("acorn/dist/walk"))
    if (typeof define == "function" && define.amd) // AMD
        return define(["tern/lib/infer", "tern/lib/tern", "tern/plugin/modules", "acorn", "acorn/dist/acorn_loose", "acorn/dist/walk"], mod)
    mod(tern, tern, acorn, acorn_loose, acorn.walk)
})(function (infer, tern, modules, acorn, acorn_loose, walk) {
    "use strict"

    var WG_IMPORT_DEFAULT_FALLBACK = 80
    var WG_DEFAULT_EXPORT = 95

    var glob = require("glob");
    var fs = require('fs');
    var cheerio = require("cheerio");

    var cmpsi = {}
    var libsi = {}

    var server = {}

    function parent(path) {
        var splits = path.split("/")
        if (splits.size == 1) return ""
        return splits[splits.length - 3]
    }

    function dirName(path) {
        var lastSlash = path.lastIndexOf("/")
        if (lastSlash == -1) return ""
        return path.slice(0, lastSlash + 1)
    }

    function baseName(path) {
        var lastSlash = path.lastIndexOf("/")
        if (lastSlash == -1) return path
        else return path.slice(lastSlash + 1)
    }

    function trimExt(path) {
        var lastDot = path.lastIndexOf(".")
        if (lastDot == -1) return path
        else return path.slice(0, lastDot)
    }

    function initScope(scope) {
        var module = new infer.Obj()
        module.propagate(scope.defProp("module"))
        var exports = new infer.Obj(true)
        module.origin = exports.origin = scope.origin
        module.originNode = exports.originNode = scope.originNode
        exports.propagate(scope.defProp("exports"))
        var moduleExports = scope.exports = module.defProp("exports")
        exports.propagate(moduleExports, WG_DEFAULT_EXPORT)
    }

    function getLibraryIncludes(library) {
        var file = libsi[library]
        var t = fs.readFileSync(server.options.projectDir + "/" + file, "utf-8")
        var $ = cheerio.load(t, {
            xmlMode: true
        })
        var a = $("aura\\:library aura\\:include")
        var bn = dirName(file)
        var includes = []
        a.each(function (i, elem) {
            includes.push(bn + $(elem).attr("name") + ".js");
        })
        return includes;
    }

    function connectModule(file, out) {

        var modules = infer.cx().parent.mod.modules

        // first thing is first, gather up all of FunctionExpressions and export them for this module
        var cx = infer.cx();


        // var cmps = glob.sync("**/*.cmp", {
        //    cwd: server.options.projectDir,
        //    ignore: "**/+(target|tmp-cache)/**",
        //    cache: cache
        // })
        // for(var i = 0;i<cmps.length;i++) {
        //   console.log(cmps[i])
        // }
        var libs = glob.sync(dirName(file.name) + "*.lib", {
            cwd: server.options.projectDir,
            ignore: [""]
        });
        if (libs.length > 0) {
            console.log("looking at: " + file.name)
            var bn = trimExt(baseName(file.name))
            var ln = trimExt(baseName(libs[0]))
            var t = fs.readFileSync(server.options.projectDir + "/" + libs[0], "utf-8")
            var $ = cheerio.load(t, {
                xmlMode: true
            })
            var a = $("aura\\:library aura\\:include")
            var imps
            a.each(function (i, elem) {
                var pp = $(elem).attr("name")
                if (bn == pp) {
                    imps = $(elem).attr("imports")
                }
            });

            // use alternate module for libs
            var ns = parent(dirName(file.name))
            var l = modules.resolveModule("mod:" + ns + ":" + ln, file.name);

            var outObj;
            if (!l.getType()) {
                outObj = new infer.Obj(true)
                outObj.origin = "Aura"
                outObj.name = baseName(libs[0])
                l.addType(outObj)
            } else {
                outObj = l.getType();
            }
            if (imps) {

                // get fn decl
                var fn = file.ast.body[0]
                var state = fn.scope;

                // bind included imports to library function....
                var imports = imps.split(',')
                for (var i = 0; i < imports.length; i++) {
                    // resolve....
                    var importedModule = imports[i].trim();
                    if (importedModule == "")
                        continue
                    var imf;
                    var lib = l;
                    if (importedModule.indexOf(':') > -1) {
                        var splits = importedModule.split(":")

                        var qn = splits[0] + ":" + splits[1];
                        if (!libsi[qn])
                            continue

                        lib = modules.resolveModule("mod:" + qn);
                        if (!lib.getType()) {
                            var zz = new infer.Obj(true)
                            zz.origin = "Aura"

                            zz.name = baseName(libsi[qn])
                            lib.addType(zz)
                        }

                        importedModule = splits[2]
                        imf = dirName(libsi[qn]) + importedModule + ".js";

                    } else {
                        imf = dirName(file.name) + importedModule + ".js";
                    }
                    if (server.findFile(imf) == null) {
                        server.addFile(imf)
                    }
                    var bno = trimExt(baseName(imf))
                    var lno = trimExt(baseName(imf))

                    var pm = state.fnType.args[i];
                    if (!pm || pm.getType(false) != null)
                        continue

                    if (lib.getType().hasProp(importedModule)) {
                        pm.addType(lib.getType().getProp(importedModule).getType());

                        var z = new infer.Obj()
                        z.origin = "BLah";
                        z.name = "XXX";
                        pm.origin = "asdf"
                            //pm.addType( z )
                    } else {
                        var pname = importedModule;
                        // so, in effect this isn't really used, since (at least tern.ide)
                        // calls content assist frequently that by the time this called back,
                        // the file will be reindex, and the other lib file would have already
                        /// been loaded.
                        lib.getType().on("addProp", function (prop, val) {
                            if (pname == prop) {
                                pm.addType(val);
                            }
                        });
                    }
                }
            }

            walk.simple(file.ast, {
                ReturnStatement: function (node, state) {
                    try {
                        var parent = infer.parentNode(node, file.ast);
                        var grand = infer.parentNode(parent, file.ast)
                        var great = infer.parentNode(grand, file.ast);
                        if (great && great["type"] === "Program") {
                            if (node.argument) {
                                if (node.argument["type"] === "Identifier") {
                                    var t = state.props[node.argument.name];
                                    if (t) {
                                        var exported = t.getObjType();
                                        outObj.defProp(bn, node.argument).addType(exported);
                                    }
                                } else if (node.argument["type"] === "ObjectExpression") {
                                    outObj.defProp(bn, node.argument).addType(node.argument.objType)
                                } else if (node.argument["type"] === "FunctionExpression") {
                                    outObj.defProp(bn, node.argument).addType(state.fnType.getType())
                                } else if (node.argument["type"] === "CallExpression") {
                                    outObj.defProp(bn, node.argument).addType(state.fnType.getType())
                                }
                            }
                        }
                    } catch (ignore) {}
                }
            }, infer.searchVisitor);

        } else {

            var cmps = glob.sync(dirName(file.name) + "*.cmp", {
                cwd: server.options.projectDir,
                ignore: [""]
            });
            if (cmps.length > 0) {
                var t = fs.readFileSync(server.options.projectDir + "/" + cmps[0], "utf-8")
                var $ = cheerio.load(t, {
                    xmlMode: true
                })
                var a = $("aura\\:import")
                $(a).each(function (i, elem) {
                    var library = $(elem).attr("library");
                    var property = $(elem).attr("property");
                    if (!libsi[library])
                        return

                    var lib = modules.resolveModule("mod:" + library, file.name);
                    if (!lib.getType()) {
                        var zz = new infer.Obj(true)
                        zz.origin = "Aura"
                        zz.name = baseName(libsi[library])
                        lib.addType(zz)

                        var inc = getLibraryIncludes(library);
                        for (var i = 0; i < inc.length; i++) {
                            if (server.findFile(inc[i]) == null) server.addFile(inc[i])
                        }
                    }

                    var t = file.scope.getObjType();
                    try {
                        walk.simple(file.ast, {
                            FunctionExpression: function (node, state) {

                                var ss = infer.scopeAt(file.ast, node)
                                var con = ss.fnType.self.getType();

                                lib.getType().propagate(con.defProp(property))

                                throw "stop"

                            }

                        }, infer.searchVisitor);
                    } catch (ignore) {}
                });
            }

        }

        if (/Helper.js$/.test(file.name)) {

            var outObj = new infer.Obj(true)
            outObj.origin = "Aura"
            outObj.originNode = file.ast
            outObj.name = baseName(file.name).replace(/.js$/, "")
            out.addType(outObj)

            try {
                walk.simple(file.ast, {
                    ObjectExpression: function (node, state) {
                        var parent = infer.parentNode(node, file.ast);
                        var grand = infer.parentNode(parent, file.ast)
                        if (grand.type == "Program") {
                            node.objType.propagate(outObj.defProp(baseName(file.name).replace(/.js$/, "")))
                            throw "stop"
                        }
                    }
                }, infer.searchVisitor)
            } catch (ignore) {

            }
            console.log("done")
        }

        var f = false;
        walk.simple(file.ast, {
            ObjectExpression: function (node, state) {
                var parent = infer.parentNode(node, file.ast);
                var grand = infer.parentNode(parent, file.ast)
                if (grand.type == "Program") {
                    for (var i = 0; i < node.properties.length; ++i) {
                        var prop = node.properties[i],
                            name = infer.propName(prop)
                        if (node.properties[i].value.type == "FunctionExpression") {

                            var fn = node.properties[i].value.scope.fnType;
                            if (!fn || !fn.name) {
                                continue;
                            }

                            if (/Renderer.js$/.test(file.name)) {
                                //step 2, assign exported type to params
                                var cmp = fn.args[0]
                                var hlp = fn.args[1]
                                if (cmp) {
                                    findAndBindComponent(cmp, server, cx, infer);
                                }
                                if (hlp) {
                                    findAndBindHelper(hlp, server, modules, file)
                                }
                            } else if (/Helper.js$/.test(file.name)) {
                                //step 2, assign exported type to params
                                var cmp = fn.args[0]

                                if (cmp) {
                                    findAndBindComponent(cmp, server, cx, infer);
                                }

                            } else if (/Controller.js$/.test(file.name)) {
                                //step 2, assign exported type to params
                                var cmp = fn.args[0]
                                var evt = fn.args[1]
                                var hlp = fn.args[2]

                                if (evt) {
                                    findAndBindEvent(evt, server, cx, infer);
                                }
                                if (cmp) {
                                    findAndBindComponent(cmp, server, cx, infer);
                                }
                                if (hlp) {
                                    findAndBindHelper(hlp, server, modules, file);
                                }
                            }
                        }
                    }
                }
            }
        })
    }

    function processLibray(file, out) {

    }

    function findAndBindEvent(type, server, cx, infer) {
        if (server.mod.localaura) {
            var files = glob.sync("aura/aura-impl/src/main/resources/aura/event/Event.js", {
                cwd: server.options.projectDir
            });
            var f = files.length > 0 ? files[0] : null
            if (f) {
                f = server.findFile(f)
                if (!f) server.addFile(f)
                if (f && f.scope) {
                    walk.simple(f.ast, {
                        FunctionExpression: function (node) {
                            if (node.scope && node.scope.proto && node.scope.fnType.props["prototype"]) {
                                var int = infer.getInstance(node.scope.fnType.props["prototype"].getObjType())
                                int.propagate(type);
                            }
                        }
                    })
                }
            }
        } else {
            // this is slightly hacky, but have no idea how to get the event Otherwise
            var evs = cx.props["Event"];
            for (var z = 0; z < evs.length; z++) {
                var y = evs[z];
                if (y.name === "Aura.Event") {
                    var obj = y.props["Event"].types[0].props["prototype"].getObjType();
                    var int = infer.getInstance(obj)
                    int.propagate(type);
                }
            }
        }
    }

    function findAndBindComponent(type, server, cx, infer) {
        if (server.mod.localaura) {
            var files = glob.sync("aura/aura-impl/src/main/resources/aura/component/Component.js", {
                cwd: server.options.projectDir
            });
            var f = files.length > 0 ? files[0] : null
            if (f) {
                f = server.findFile(f)
                if (!f) server.addFile(f)
                if (f && f.scope) {
                    var int = infer.getInstance(f.scope.getType().props["Component"].props["prototype"].getObjType())
                    int.propagate(type)
                }
            }
        } else {
            var evs = cx.props["Component"];
            for (var z = 0; z < evs.length; z++) {
                var y = evs[z];
                if (y.name === "Aura.Component") {
                    var obj = y.props["Component"].types[0].props["prototype"].getObjType();
                    var int = infer.getInstance(obj)
                    int.propagate(type);
                }
            }
        }
    }

    function findAndBindHelper(type, server, modules, file) {
        var helperFile = getHelper(file.name);
        var bn = trimExt(baseName(helperFile));
        var r = server.findFile(helperFile);
        if (!r) server.addFile(helperFile)
        var helper = modules.resolveModule(helperFile)
        if (helper.getType(false) != null) {
            if (helper.getType().hasProp(bn)) {
                type.addType(helper.getType().getProp(bn).getType())
            }
        }
        //  helper.getType().propagateTo(type)
    }

    function getController(name) {
        return getName(name, "Controller.js")
    }

    function getHelper(name) {
        return getName(name, "Helper.js")
    }

    function getRenderer(name) {
        return getName(name, "Renderer.js")
    }

    function getTest(name) {
        return getName(name, "Test.js")
    }

    function getName(name, type) {
        var newname = name.replace(/Controller.js$|Helper.js$|Renderer.js$|Test.js$/, "") + type
        return newname
    }

    function resolver(file, parent) {
        return file
    }

    tern.registerPlugin("auraframework", function (s) {
        server = s;
        server.loadPlugin("modules")
        server.mod.modules.on("wrapScope", initScope)
        server.mod.modules.on("getExports", connectModule)
        server.mod.modules.resolvers.push(resolver)


        var s = glob.sync("aura/aura-impl/**/*.js", {
            cwd: server.options.projectDir
        });
        if (s.length > 0) {
            server.mod.localaura = true
        } else {
            server.mod.localaura = false
        }
        //server.mod.localaura=false
        if (server.mod.localaura) {
            for (var i = 0; i < s.length; i++) {
                var f = s[i]
                server.addFile(s[i])
            }
        } else {
            var defs = fs.readFileSync(dirName(__filename) + "/aura_types.json", "utf-8")
            defs = JSON.parse(defs);
            server.addDefs(defs)
        }


        var cache = {}
        try {
            var c = fs.readFileSync(server.options.projectDir + "/cmps.json", "utf-8");
            cmpsi = JSON.parse(c);
        } catch (Err) {
            console.log(Err)
            console.log(new Date().toISOString() + ' Building .cmp index...')
            glob("**/*.cmp", {
                cwd: server.options.projectDir,
                ignore: "**/+(target|tmp-cache|java|build|htdocs|plsql|test)/**",
                cache: cache
            }, function (err, files) {

                console.log(new Date().toISOString() + ' done indexing .cmps ' + files.length)
                for (var i = 0; i < files.length; i++) {
                    var file = files[i]

                    var ns = parent(dirName(file))
                    var n = trimExt(baseName(file))

                    cmpsi[ns + ":" + n] = file;
                }
                fs.writeFileSync(server.options.projectDir + "/cmps.json", JSON.stringify(cmpsi), "utf-8")

            })
        }
        try {
            var c = fs.readFileSync(server.options.projectDir + "/libs.json", "utf-8");
            libsi = JSON.parse(c);
        } catch (Err) {
            console.log(Err);
            console.log(new Date().toISOString() + ' Building .lib index...')

            glob("**/*.lib", {
                cwd: server.options.projectDir,
                ignore: "**/+(target|tmp-cache|java|build|htdocs|plsql|test)/**",
                cache: cache
            }, function (err, files) {
                //console.log(cache)
                console.log(new Date().toISOString() + ' done indexing .libs ' + files.length)
                for (var i = 0; i < files.length; i++) {
                    var file = files[i]

                    var ns = parent(dirName(file))
                    var n = trimExt(baseName(file))

                    libsi[ns + ":" + n] = file;
                }
                fs.writeFileSync(server.options.projectDir + "/libs.json", JSON.stringify(libsi), "utf-8")

            })
        }
        console.log(new Date().toISOString() + ' Done loading!')
    })
    tern.defineQueryType("collectMethods", {
        run: function (server, query) {
            var text;
            if (query.file) {
                text = fs.readFileSync(query.file, "utf-8")
            }
            if (query.contents) {
                text = query.contents;
            }

            var options = {
                ecmaVersion: 6,
            };
            var ast;
            try {
                ast = acorn.parse(text, options);
            } catch (err) {
                ast = acorn_loose.parse_dammit(text, options);
            }
            var methods = [];
            if (ast) {
                if (query.library) {
                    walk.ancestor(ast, {
                        ReturnStatement: function (node, state) {
                            try {
                                var parent = state[state.length - 2];
                                var grand = state[state.length - 3];
                                var great = state[state.length - 4];
                                if (great && great["type"] === "Program") {
                                    if (node.argument) {
                                        if (node.argument["type"] === "Identifier") {
                                            //not handled
                                        } else if (node.argument["type"] === "ObjectExpression") {
                                            visitObjExpressProps(node.argument);
                                        } else if (node.argument["type"] === "FunctionExpression") {
                                            // not handled
                                        } else if (node.argument["type"] === "CallExpression") {
                                            // not handled
                                        }
                                    }
                                }
                            } catch (ignore) {
                                console.log(ignore);
                            }
                        }
                    });
                } else {
                    visitObjExpress(ast, methods);
                }

            }

            function visitObjExpress(ast, methods) {
                // Walk the error-tolerant parser AST
                walk.ancestor(ast, {
                    ObjectExpression: function (node, state) {
                        var parent = state[state.length - 2];
                        var grand = state[state.length - 3]
                        if (grand.type == "Program") {
                            visitObjExpressProps(node);
                        }
                    }
                });
            }

            function visitObjExpressProps(node) {
                for (var i = 0; i < node.properties.length; i++) {
                    var prop = node.properties[i],
                        name = infer.propName(prop)

                    var args = []
                    if (prop.value.params) {
                        for (var a = 0; a < prop.value.params.length; a++) {
                            var pid = prop.value.params[a]
                            args.push(pid.name);
                        }
                    }
                    methods.push({
                            method: name,
                            start: prop.key.start,
                            end: prop.key.end,
                            args: args
                        })
                        //methods.push({ method: name, start: node.start, end: node.end, args: args})
                }
            }
            return {
                methods: methods
            };
        }
    });
    tern.defineQueryType("collectStrings", {
        run: function (server, query) {
            var text;
            if (query.file) {
                text = fs.readFileSync(query.file, "utf-8")
            }
            if (query.contents) {
                text = query.contents;
            }

            var options = {
                ecmaVersion: 6,
            };
            var ast;
            try {
                ast = acorn.parse(text, options);
            } catch (err) {
                ast = acorn_loose.parse_dammit(text, options);
            }
            var methods = [];
            if (ast) {
                walk.simple(ast, {
                    Literal: function (node) {
                        if (typeof node.value == "string" && node.value && node.value.length < 100 && node.value.length > 1) {
                            if (node.value.indexOf(":") > -1) {
                                var match = /(\w+):(\w+)/.exec(node.value);
                                if (match && match.length==3) {
                                  methods.push({ns:match[1], name:match[2]});
                                }
                            }
                        }
                    }
                });
            }
            return {
                strings: methods
            };
        }
    });
})



//"**/aura-impl/**/event/Event.js"
// glob.sync("aura/aura-impl/src/main/resources/aura/event/Event.js", {
//   cwd: server.options.projectDir
// },
// function(er,files) {
//   if (files.length>0) {
//     var file = server.findFile(files[0])
//     if (!file) server.addFile(files[0])
//     if (file && file.scope) {
//        evt.addType(file.scope)
//     }
//   }
// })

// var files = glob.sync("aura/aura-impl/src/main/resources/aura/event/Event.js", {
//   cwd: server.options.projectDir
// });
// var f = files.length>0 ? files[0] : null
// if (f) {
//   f = server.findFile(f)
//   if (!f) server.addFile(f)
//   if (f && f.scope) {
//     walk.simple(f.ast, {
//       FunctionExpression: function(node) {
//         if (node.scope && node.scope.proto && node.scope.fnType.props["prototype"]) {
//           var int = infer.getInstance(node.scope.fnType.props["prototype"].getObjType())
//           int.propagate(evt);
//         }
//       }
//     })
//   }
// }
