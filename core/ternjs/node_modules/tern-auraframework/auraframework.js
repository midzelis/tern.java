(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    return mod(require("tern/lib/infer"), require("tern/lib/tern"), require("tern/plugin/modules"), require('acorn'), require('acorn/dist/acorn_loose'), require("acorn/dist/walk"))
  if (typeof define == "function" && define.amd) // AMD
    return define(["tern/lib/infer", "tern/lib/tern", "tern/plugin/modules", "acorn",  "acorn/dist/acorn_loose", "acorn/dist/walk"], mod)
  mod(tern, tern, acorn, acorn_loose, acorn.walk)
})(function(infer, tern, modules, acorn, acorn_loose, walk) {
  "use strict"

  var WG_IMPORT_DEFAULT_FALLBACK = 80

  function dirName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return ""
    return path.slice(0, lastSlash + 1)
  }
  function baseName(path) {
    var lastSlash = path.lastIndexOf("/")
    if (lastSlash == -1) return path
    else return path.slice(lastSlash + 1)
  }

  function connectModule(file, out) {
    var modules = infer.cx().parent.mod.modules

    // first thing is first, gather up all of FunctionExpressions and export them for this module
    var cx = infer.cx(), server = cx.parent
    var fns = []

    var outObj = new infer.Obj(true)
    outObj.origin = file.name
    outObj.originNode= file.ast
    outObj.name=baseName(file.name).replace(/.js$/,"")
    out.addType(outObj)

    walk.simple(file.ast, {
      ObjectExpression: function(node) {
        for (var i = 0; i < node.properties.length; ++i) {
          var prop = node.properties[i], name = infer.propName(prop)
          if (node.properties[i].value.type == "FunctionExpression") {
            //step 1, export and propagate function
            var a = infer.findExpressionAt(node.properties[i])
            var fn = a.state.fnType;
            if (!fn || !fn.name) {
              continue;
            }
            fns.push(fn)
            fn.propagate( outObj.defProp(fn.name) )

            if (/Renderer.js$/.test(file.name)) {
              //step 2, assign exported type to params
              var cmp = fn.args[0]
              var hlp = fn.args[1]
              if (cmp) {
                findAndBindComponent(cmp, server, cx, infer);
              }
              if (hlp) {
                findAndBindHelper(hlp, modules, files);
              }
            } else if (/Helper.js$/.test(file.name)) {
              //step 2, assign exported type to params
              var cmp = fn.args[0]
              
              if (cmp) {
                findAndBindComponent(cmp, server, cx, infer);
              }

            } else if (/Controller.js$/.test(file.name)) {
              //step 2, assign exported type to params
              var cmp = fn.args[0]
              var evt = fn.args[1]
              var hlp = fn.args[2]

              if (evt) {
                findAndBindEvent(evt, server, cx, infer);
              }
              if (cmp) {
                findAndBindComponent(cmp, server, cx, infer);
              }
              if (hlp) {
                findAndBindHelper(hlp, modules, file);
              }
            }
          }
        }
      }
    })
  }

  function findAndBindEvent(type, server, cx, infer) {
    var glob = require("glob")
    if (server.mod.localaura) {
      var files = glob.sync("aura/aura-impl/src/main/resources/aura/event/Event.js", {
        cwd: server.options.projectDir
      });
      var f = files.length>0 ? files[0] : null
      if (f) {
        f = server.findFile(f)
        if (!f) server.addFile(f)
        if (f && f.scope) {
          walk.simple(f.ast, {
            FunctionExpression: function(node) {
              if (node.scope && node.scope.proto && node.scope.fnType.props["prototype"]) {
                var int = infer.getInstance(node.scope.fnType.props["prototype"].getObjType())
                int.propagate(type);
              }
            }
          })
        }
      }
    } else {
      // this is slightly hacky, but have no idea how to get the event Otherwise
      var evs = cx.props["Event"];
      for(var z=0;z<evs.length;z++) {
        var y = evs[z];
        if (y.name === "Aura.Event") {
          var type = y.props["Event"].types[0].props["prototype"].getObjType();
          var int = infer.getInstance(type)
          int.propagate(type);
        }
      }
    }
  }

  function findAndBindComponent(type, server, cx, infer) {
    if (server.mod.localaura) {
      var files = glob.sync("aura/aura-impl/src/main/resources/aura/component/Component.js", {
        cwd: server.options.projectDir
      });
      var f = files.length>0 ? files[0] : null
      if (f) {
        f = server.findFile(f)
        if (!f) server.addFile(f)
        if (f && f.scope) {
          var int = infer.getInstance( f.scope.getType().props["Component"].props["prototype"].getObjType() )
          int.propagate(type)
        }
      }
    } else {
      var evs = cx.props["Component"];
      for(var z=0;z<evs.length;z++) {
        var y = evs[z];
        if (y.name === "Aura.Component") {
          var type = y.props["Component"].types[0].props["prototype"].getObjType();
          var int = infer.getInstance(type)
          int.propagate(type);
        }
      }
    }
  }

  function findAndBindHelper(type, modules,file) {
    var helper = modules.resolveModule(getHelper(file.name))
    type.addType(helper);
  }

  function getController(name) {
    return getName(name,"Controller.js")
  }
  function getHelper(name) {
    return getName(name,"Helper.js")
  }
  function getRenderer(name) {
    return getName(name,"Renderer.js")
  }
  function getTest(name) {
    return getName(name,"Test.js")
  }
  function getName(name,type) {
    var newname = name.replace(/Controller.js$|Helper.js$|Renderer.js$|Test.js$/,"") + type
    return newname
  }

function resolver(file, parent) {
  return file
}

  tern.registerPlugin("auraframework", function(server) {

    server.loadPlugin("modules")
    server.mod.modules.on("getExports", connectModule)
    server.mod.modules.resolvers.push(resolver)

    var glob = require('glob')
    var s = glob.sync("aura/aura-impl/**/*.js", {
      cwd: server.options.projectDir
    });
    if (s.length>0) {
      server.mod.localaura=true
    } else {
      server.mod.localaura=false
    }
    //server.mod.localaura=false
    if (server.mod.localaura) {
      for(var i=0;i<s.length;i++) {
        var f = s[i]
        server.addFile(s[i])
      }
    } else {
      var defs = require('fs').readFileSync(dirName(__filename)+"/aura_types.json","utf-8")
      defs = JSON.parse(defs);
      server.addDefs(defs)
    }
    console.log('done loading')
  })
  tern.defineQueryType("collectMethods", {
      run: function (server, query) {
        var text = require('fs').readFileSync(query.file,"utf-8")

        var options = {
          ecmaVersion: 6,
        };
        var ast;
        try {
            ast = acorn.parse(text, options);
        } catch (err) {
            ast = acorn_loose.parse_dammit(text, options);
        }
        var methods = [];
        if (ast) {
            // Walk the error-tolerant parser AST
            walk.ancestor(ast, {
              FunctionExpression: function(node,state) {
                 if (state[state.length-2].type==="Property") {
//                   var name = state[state.length-2].key.name;
//                   var args = []
//                   for (var a = 0;a<node.params.length;a++) {
//                      var pid = node.params[a].name;
//                      args.push(pid);
//                   }
                   
                   var parent = state[state.length-2].key;
                   var name = parent.name;
                   var args = []
                   for (var a = 0;a<node.params.length;a++) {
                      var pid = node.params[a].name;
                      args.push(pid);
                   }
                   methods.push({ method: name, start: parent.start, end: parent.end, args: args})
                   //methods.push({ method: name, start: node.start, end: node.end, args: args})
                 }
              }
            });
        }

        return {
            methods: methods
        };
      }
  });

})



//"**/aura-impl/**/event/Event.js"
// glob.sync("aura/aura-impl/src/main/resources/aura/event/Event.js", {
//   cwd: server.options.projectDir
// },
// function(er,files) {
//   if (files.length>0) {
//     var file = server.findFile(files[0])
//     if (!file) server.addFile(files[0])
//     if (file && file.scope) {
//        evt.addType(file.scope)
//     }
//   }
// })

// var files = glob.sync("aura/aura-impl/src/main/resources/aura/event/Event.js", {
//   cwd: server.options.projectDir
// });
// var f = files.length>0 ? files[0] : null
// if (f) {
//   f = server.findFile(f)
//   if (!f) server.addFile(f)
//   if (f && f.scope) {
//     walk.simple(f.ast, {
//       FunctionExpression: function(node) {
//         if (node.scope && node.scope.proto && node.scope.fnType.props["prototype"]) {
//           var int = infer.getInstance(node.scope.fnType.props["prototype"].getObjType())
//           int.propagate(evt);
//         }
//       }
//     })
//   }
// }
